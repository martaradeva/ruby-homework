# Proc Placeholder

Много обичаме съкратения вариант за извикване на блок през символ.

    ["all", "fancy", "words"].map(&:length)    # [3, 5, 5]

Толкова много, че започваме да страдаме поради факта, че няма как да подаваме аргументи на блок-а по също толкова елегантен начин, а се налага да разписваме целия proc.

    (1..5).map { |n| n ** 2 }    # [1, 4, 9, 16, 25]

Понеже знаем, че Ruby е красив, елегантен и в същото време мощен, ще се опитаме да запълним тази "липса".

Целта на това предизвикателство е да дефинирате въображаемия обект `P`. Този обект ще играе ролята на placeholder, върху който можем да извикваме методи, подавайки им аргументи. Тези методи ще бъдат извиквани върху всеки един елемент от колекцията, подобно на стандартен блок. Например:

    (1..5).map(&P ** 2)    # [1, 4, 9, 16, 25]

Тук виждаме как методът `**` се извиква върху фиктивния обект P с аргумент 2, което кара `map` да приложи тази операция върху всеки обект от колекцията. Или пък:

    [[1, 2, 3, 8], [4, 5], [6]].map(&P.select(&:even?))    # [[2, 8], [4], [6]]

Ако не извикаме метод на обекта `P`, очакваме той да работи като идентитет:

    (1..5).map(&P)    # [1, 2, 3, 4, 5]

## One more thing..

Въображаемият обект `P` трябва да е способен да прехвърли всяко съобщение на правилния получател, дори неща от рода на `instance_eval` и `__id__`. Подсказка: прокси.
